/**
 * Admin Permissions System
 *
 * Handles role-based access control for admin operations including:
 * - Permission validation for specific actions
 * - Resource-scoped permissions (fandom-specific access)
 * - Role hierarchy (ProjectAdmin vs FandomAdmin)
 * - Action authorization and audit logging
 *
 * @package the-pensive-index
 * @version 1.0.0
 */

import type { AdminUser, AdminPermission, AdminRole } from '../../types/admin';

/**
 * Permission validation result
 */
export interface PermissionResult {
  hasPermission: boolean;
  scope: 'global' | 'fandom' | 'none';
  resource?: string;
  reason?: string;
}

/**
 * Available permission actions in the system
 */
export enum PermissionAction {
  // Rule management
  RULE_CREATE = 'rule:create',
  RULE_READ = 'rule:read',
  RULE_UPDATE = 'rule:update',
  RULE_DELETE = 'rule:delete',

  // Template management (ProjectAdmin only)
  TEMPLATE_CREATE = 'template:create',
  TEMPLATE_MANAGE = 'template:manage',
  TEMPLATE_DELETE = 'template:delete',

  // Admin user management (ProjectAdmin only)
  ADMIN_CREATE = 'admin:create',
  ADMIN_MANAGE = 'admin:manage',
  ADMIN_DELETE = 'admin:delete',

  // Fandom access
  FANDOM_ACCESS = 'fandom:access',
  FANDOM_MANAGE = 'fandom:manage',

  // Content moderation
  CONTENT_MODERATE = 'content:moderate',
  CONTENT_REVIEW = 'content:review',

  // System administration (ProjectAdmin only)
  SYSTEM_CONFIG = 'system:config',
  SYSTEM_AUDIT = 'system:audit',
}

/**
 * Default permissions by role
 */
const DEFAULT_PERMISSIONS: Record<AdminRole, PermissionAction[]> = {
  ProjectAdmin: [
    // Full access to everything
    PermissionAction.RULE_CREATE,
    PermissionAction.RULE_READ,
    PermissionAction.RULE_UPDATE,
    PermissionAction.RULE_DELETE,
    PermissionAction.TEMPLATE_CREATE,
    PermissionAction.TEMPLATE_MANAGE,
    PermissionAction.TEMPLATE_DELETE,
    PermissionAction.ADMIN_CREATE,
    PermissionAction.ADMIN_MANAGE,
    PermissionAction.ADMIN_DELETE,
    PermissionAction.FANDOM_ACCESS,
    PermissionAction.FANDOM_MANAGE,
    PermissionAction.CONTENT_MODERATE,
    PermissionAction.CONTENT_REVIEW,
    PermissionAction.SYSTEM_CONFIG,
    PermissionAction.SYSTEM_AUDIT,
  ],
  FandomAdmin: [
    // Limited to rule management and assigned fandoms
    PermissionAction.RULE_CREATE,
    PermissionAction.RULE_READ,
    PermissionAction.RULE_UPDATE,
    PermissionAction.RULE_DELETE,
    PermissionAction.FANDOM_ACCESS,
    PermissionAction.CONTENT_MODERATE,
    PermissionAction.CONTENT_REVIEW,
  ],
};

/**
 * Admin permissions management system
 */
export class AdminPermissions {
  /**
   * Validates if a user has permission to perform an action on a resource
   *
   * @param user - Admin user to check permissions for
   * @param action - Action to validate (e.g., 'rule:create')
   * @param resource - Optional resource identifier (e.g., fandomId)
   * @returns PermissionResult with validation details
   */
  static validatePermission(
    user: AdminUser,
    action: string,
    resource?: string
  ): PermissionResult {
    // Check if user exists and has valid assignments
    if (!user || !user.assignments || user.assignments.length === 0) {
      return {
        hasPermission: false,
        scope: 'none',
        reason: 'Invalid user or no role assignments',
      };
    }

    // Check if action is supported
    const actionEnum = Object.values(PermissionAction).find(a => a === action);
    if (!actionEnum) {
      return {
        hasPermission: false,
        scope: 'none',
        reason: `Unknown action: ${action}`,
      };
    }

    // ProjectAdmin has global access to everything
    if (user.role === 'ProjectAdmin') {
      return {
        hasPermission: true,
        scope: 'global',
        resource,
      };
    }

    // FandomAdmin has limited permissions
    if (user.role === 'FandomAdmin') {
      return this.validateFandomAdminPermission(user, actionEnum, resource);
    }

    return {
      hasPermission: false,
      scope: 'none',
      reason: 'Unrecognized role',
    };
  }

  /**
   * Validates FandomAdmin permissions with resource scoping
   */
  private static validateFandomAdminPermission(
    user: AdminUser,
    action: PermissionAction,
    resource?: string
  ): PermissionResult {
    const fandomAdminActions = DEFAULT_PERMISSIONS.FandomAdmin;

    // Check if action is allowed for FandomAdmin
    if (!fandomAdminActions.includes(action)) {
      return {
        hasPermission: false,
        scope: 'none',
        reason: `Action ${action} not permitted for FandomAdmin`,
      };
    }

    // For resource-specific actions, check fandom access
    if (resource && this.isResourceScopedAction(action)) {
      // Check if user has access to this fandom
      if (!user.fandom_access || !user.fandom_access.includes(resource)) {
        return {
          hasPermission: false,
          scope: 'none',
          resource,
          reason: `No access to fandom: ${resource}`,
        };
      }

      return {
        hasPermission: true,
        scope: 'fandom',
        resource,
      };
    }

    // Action is allowed and no resource scoping needed
    return {
      hasPermission: true,
      scope: user.fandom_access && user.fandom_access.length > 0 ? 'fandom' : 'none',
      resource,
    };
  }

  /**
   * Checks if an action requires resource scoping
   */
  private static isResourceScopedAction(action: PermissionAction): boolean {
    const resourceScopedActions = [
      PermissionAction.RULE_CREATE,
      PermissionAction.RULE_UPDATE,
      PermissionAction.RULE_DELETE,
      PermissionAction.FANDOM_ACCESS,
      PermissionAction.CONTENT_MODERATE,
      PermissionAction.CONTENT_REVIEW,
    ];

    return resourceScopedActions.includes(action);
  }

  /**
   * Gets all available permissions for a user
   *
   * @param user - Admin user
   * @returns Array of AdminPermission objects
   */
  static getUserPermissions(user: AdminUser): AdminPermission[] {
    if (!user || !user.role) {
      return [];
    }

    const rolePermissions = DEFAULT_PERMISSIONS[user.role];
    const permissions: AdminPermission[] = [];

    for (const action of rolePermissions) {
      if (user.role === 'ProjectAdmin') {
        // ProjectAdmin has global permissions
        permissions.push({
          action,
          granted: true,
        });
      } else if (user.role === 'FandomAdmin') {
        // FandomAdmin has scoped permissions
        if (this.isResourceScopedAction(action) && user.fandom_access) {
          // Add permission for each fandom
          for (const fandomId of user.fandom_access) {
            permissions.push({
              action,
              resource: fandomId,
              granted: true,
            });
          }
        } else {
          // Non-scoped permissions
          permissions.push({
            action,
            granted: true,
          });
        }
      }
    }

    return permissions;
  }

  /**
   * Checks if a user has admin privileges (any admin role)
   *
   * @param user - User to check
   * @returns boolean indicating admin status
   */
  static isAdmin(user: any): user is AdminUser {
    return (
      user && user.role && ['ProjectAdmin', 'FandomAdmin'].includes(user.role)
    );
  }

  /**
   * Checks if a user is a ProjectAdmin (highest privilege)
   *
   * @param user - User to check
   * @returns boolean indicating ProjectAdmin status
   */
  static isProjectAdmin(user: AdminUser): boolean {
    return user.role === 'ProjectAdmin';
  }

  /**
   * Checks if a user is a FandomAdmin for specific fandom
   *
   * @param user - User to check
   * @param fandomId - Fandom ID to check access for
   * @returns boolean indicating fandom admin status
   */
  static isFandomAdmin(user: AdminUser, fandomId: string): boolean {
    return (
      user.role === 'FandomAdmin' && Boolean(user.fandom_access?.includes(fandomId))
    );
  }

  /**
   * Creates a new admin user with default permissions
   *
   * @param userId - Base user ID
   * @param role - Admin role to assign
   * @param fandomIds - Fandom IDs for FandomAdmin (optional)
   * @returns Partial AdminUser object (needs to be completed with User data)
   */
  static createAdminUser(
    userId: string,
    role: AdminRole,
    fandomIds?: string[]
  ): Partial<AdminUser> {
    const permissions = this.getUserPermissions({
      role,
      fandom_access: fandomIds,
      id: userId,
      email: '',
      name: '',
      is_active: true,
      created_at: new Date(),
      updated_at: new Date(),
      permissions: []
    } as AdminUser);

    return {
      role,
      fandom_access: role === 'FandomAdmin' ? fandomIds : undefined,
      permissions: permissions as any, // TODO: Fix type mismatch
      created_at: new Date(),
      updated_at: new Date(),
    };
  }

  /**
   * Validates permission request format
   *
   * @param action - Action string to validate
   * @param resource - Optional resource string
   * @returns boolean indicating if request is valid
   */
  static isValidPermissionRequest(action: string, resource?: string): boolean {
    // Check if action exists
    const actionExists = Object.values(PermissionAction).includes(
      action as PermissionAction
    );
    if (!actionExists) {
      return false;
    }

    // Check if resource is required but missing
    const actionEnum = action as PermissionAction;
    const resourceRequired = this.isResourceScopedAction(actionEnum);

    if (resourceRequired && !resource) {
      return false;
    }

    return true;
  }

  /**
   * Formats permission result for API responses
   *
   * @param result - PermissionResult to format
   * @returns Formatted object for JSON responses
   */
  static formatPermissionResult(result: PermissionResult) {
    return {
      hasPermission: result.hasPermission,
      scope: result.scope,
      resource: result.resource,
      reason: result.reason,
    };
  }
}
